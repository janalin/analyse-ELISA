[
["index.html", "Analyse ELISA data in R 1 Introduction 1.1 About the experiment in brief 1.2 Load libraries and import excel fiele 1.3 Set cell indices and set experimental parameteres", " Analyse ELISA data in R JL 2018-08-27 1 Introduction This document shows how to analyse ELISA data in R. The code was written to analyse ELISA experiments performed in our lab: the script reads the excel file provided by a Synergy H1 96-well plate reader from BioTek, performs a background-correction, generates the calibration curve and computes the sample concentrations with respect to this calibration curve. 1.1 About the experiment in brief We measured the IgG amount in blood serum of four donors using an indirect ELISA. The detection antibody was conjugated to horseradish peroxidase (HRP). As a substrate solution, we used TMB from Thermo Fisher Scientific. We measured absorbance at 450 nm – to measure the substrate specific absorbance – and at 620 nm – to measure the (unspecific) background absorbance. The absorbance of both wavelength is provided by the plate reader in a single excel sheet. If we say background correction we mean that we substract the values obtained at 620 nm from the values obtained at 450 nm. 1.2 Load libraries and import excel fiele We first load some R libraries that we want to use. # load packages if (!requireNamespace(&quot;pacman&quot;, quietly = TRUE)){ install.packages(&quot;pacman&quot;)} pacman::p_load(bookdown, # to create this document tidyverse, # for data wrangling ggplot2, cowplot, # for nice plots scales, # for axis scales with &#39;%&#39; gdata, # to read excel files here, # to find the absolute path of the project purrr, # for functional programming viridis, # for color palettes drc, minpack.lm) # for 4-param logistic regression Now we read the excel file: # Get the project path path &lt;- here::here() # Set the name of the excel file file &lt;- &quot;/../data/180821-IgG_HV_Test.xlsx&quot; # Import excel data data &lt;- gdata::read.xls(paste0(path, file), sheet = 1, header = FALSE) %&gt;% as.tibble # Let&#39;s have a look at the absorbance data. head(data[complete.cases(data),]) ## # A tibble: 6 x 15 ## V1 V2 V3 V4 V5 V6 V7 V8 V9 V10 V11 V12 ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 &quot;&quot; A 1.73 1.74 0.27 0.279 0.523 0.543 0.708 0.683 0.835 0.846 ## 2 &quot;&quot; &quot;&quot; 0.038 0.039 0.042 0.036 0.037 0.036 0.035 0.037 0.035 0.037 ## 3 &quot;&quot; B 1.33 1.35 0.468 0.472 0.652 0.682 0.827 0.797 0.762 0.832 ## 4 &quot;&quot; &quot;&quot; 0.039 0.035 0.037 0.035 0.037 0.039 0.037 0.036 0.037 0.036 ## 5 &quot;&quot; C 0.902 0.921 0.38 0.426 1.31 1.27 0.893 0.857 0.811 0.8 ## 6 &quot;&quot; &quot;&quot; 0.037 0.037 0.037 0.075 0.037 0.037 0.037 0.038 0.037 0.038 ## # ... with 3 more variables: V13 &lt;dbl&gt;, V14 &lt;dbl&gt;, V15 &lt;int&gt; The odd rows show the absorbance at 450 nm and the even rows the absorbance at 620 nm. As expected, the background absorbance at 620 nm is very low. And these are our plate reader specifications # Inspect plate reader specifications: data[,1:2] ## # A tibble: 37 x 2 ## V1 V2 ## &lt;fct&gt; &lt;fct&gt; ## 1 Software Version 2.05.5 ## 2 Experiment File Path: &quot;&quot; ## 3 Protocol File Path: &quot;&quot; ## 4 Plate Number Plate 1 ## 5 Date 2018-08-21 ## 6 Time 16:23:34.00 ## 7 Reader Type: Synergy H1 ## 8 Reader Serial Number: 271844 ## 9 Reading Type Reader ## 10 Procedure Details &quot;&quot; ## # ... with 27 more rows 1.3 Set cell indices and set experimental parameteres We need to specify some experiment-specific parameters manually such as the position of the wells with the standard samples and blanks, the number of replicates, etc. # Use View(data) to double-check row and column indices ## BLANKS # Location of the 450 nm measurment of our blanks row.idx.blank &lt;- 36 col.idx.blank &lt;- 13 ## STANDARD SAMPLES # Location of the 450 nm measurment of the first well # of our standard (well 1A in our case) row.idx.std &lt;- 22 col.idx.std &lt;- 3 # Number of replicates of the standard n.repl.std &lt;- 2 # Maximal concentration of the standard max.conc.std &lt;- 1 # i.e. 100 %, we use a relative scale # Number of dilutions performed to obtain the calibration curve n.dilutions &lt;- 8 # Dilution factor dilution.fact = 2 ## BIOLOGICAL SAMPLES # Location of first well with the sample of the first donor (here well 3A) row.idx.donor.1 &lt;- 22 col.idx.donor.1 &lt;- 5 n.donors &lt;- 4 tpoints &lt;- c(0, 7, 30, 60, 180) n.repl.donors &lt;- 2 Now we can start analysing the data. "],
["correct-data.html", "2 Correct data", " 2 Correct data First, we define functions to 1) get background-corrected values of our samples, 2) compute the standard concentrations, and 3) to get tidy data frames of the standard and the biological samples. # Gets samples, performs background correction # Works only on single rows of the 96-well plate # The number of columns is user defined (set n.cols) #&#39; @param data input data frame #&#39; @param row.idx row index in the input data frame of the sample #&#39; @param col.dix column index in the input data frame of the first cell of the sample #&#39; @param n.cols number of columns to get in the input data frame #&#39; @return a data frame with background-corrected values correct.sample &lt;- function(data, row.idx, col.idx, n.cols) { row.end &lt;- row.idx + 1 # we select only two rows (450 nm and 620 nm measurements) col.end &lt;- col.idx + (n.cols - 1) # the number of columns is user defined sample &lt;- data %&gt;% .[row.idx:row.end, col.idx:col.end] corr.sample &lt;- sample[1, ] - sample[2, ] return(as.tibble(corr.sample)) } # Compute dilution series #&#39; @param max.conc.std maximal concentration #&#39; @param n.dilutions number of dilutions performed #&#39; @param dilution.fact dilution factor #&#39; @return a vector with concentrations comp.conc &lt;- function( max.conc.std = max.conc.std, n.dilutions = n.dilutions, dilution.fact = dilution.fact) { dilutions &lt;- sapply( seq(0, (n.dilutions - 1)), function(x) max.conc.std / (dilution.fact^x) ) return(dilutions) } # Get background-corrected standard # TODO: add documentation get.standard &lt;- function(data = data, row.idx = row.idx.std, col.idx = col.idx.std, n.dilutions = n.dilutions, n.repl = n.repl, dilution.fact = dilution.fact, max.conc.std = max.conc.std, concentration = concentrations) { row.end &lt;- row.idx + (n.dilutions * 2) - 1 col.end &lt;- col.idx + (n.repl - 1) standard &lt;- data %&gt;% .[row.idx:row.end, col.idx:col.end] corr.standard &lt;- purrr::map_df( seq(1, row.end, by = 2), ~ correct.sample(data = standard, ., col.idx = 1, n.cols = n.repl) ) %&gt;% na.omit() %&gt;% setNames(seq(n.repl)) %&gt;% dplyr::mutate(concentration = concentrations) %&gt;% tidyr::gather(key = replicate, value = absorbance, -concentration) return(corr.standard) } # TODO: add documentation get.donors &lt;- function(row.idx = row.idx.donor.1, col.idx = col.idx.donor.1, n.cols = n.repl.donors * length(tpoints)) { row.end &lt;- row.idx + 1 # 450 nm and 620 nm col.end &lt;- col.idx + (n.cols - 1) sample &lt;- data %&gt;% .[row.idx:row.end, col.idx:col.end] corr.donors &lt;- correct.sample( data = sample, row.idx = 1, col.idx = 1, n.cols = n.cols ) return(corr.donors) } Now we can create a data frame with the corrected data of the standard: concentrations &lt;- comp.conc( max.conc.std = max.conc.std, n.dilutions = n.dilutions, dilution.fact = dilution.fact ) standard &lt;- get.standard( data = data, row.idx = row.idx.std, col.idx = col.idx.std, n.dilutions = n.dilutions, n.repl = n.repl.std, dilution.fact = dilution.fact, max.conc.std = max.conc.std, concentration = concentrations ) # Inspect result standard ## # A tibble: 16 x 3 ## concentration replicate absorbance ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 1 1.69 ## 2 0.5 1 1.29 ## 3 0.25 1 0.865 ## 4 0.125 1 0.689 ## 5 0.0625 1 0.26 ## 6 0.0312 1 0.128 ## 7 0.0156 1 0.059 ## 8 0.00781 1 0.033 ## 9 1 2 1.70 ## 10 0.5 2 1.32 ## 11 0.25 2 0.884 ## 12 0.125 2 0.671 ## 13 0.0625 2 0.262 ## 14 0.0312 2 0.121 ## 15 0.0156 2 0.062 ## 16 0.00781 2 0.032 Here we select the wells with the blanks: # get blanks blanks &lt;- correct.sample(data, row.idx.blank, col.idx.blank, n.cols = 2) %&gt;% setNames(seq(1, dim(.)[2])) %&gt;% tidyr::gather(key = replicate, value = blank) # Inpsect blanks blanks ## # A tibble: 2 x 2 ## replicate blank ## &lt;chr&gt; &lt;dbl&gt; ## 1 1 0.004 ## 2 2 0.00500 And finally we create a data frame with the corrected data of our biological samples. In our case, we have a time series with five data points for four donors: donors &lt;- purrr::map_df( seq(row.idx.donor.1, (row.idx.donor.1 + 2 * (n.donors - 1)), by = 2), ~ get.donors(., col.idx = col.idx.donor.1, n.cols = 10) ) %&gt;% setNames(c(0.1,0.2,7.1,7.2,30.1,30.2,60.1, 60.2, 180.1, 180.2)) %&gt;% dplyr::mutate(donor = seq(1, n.donors)) %&gt;% dplyr::mutate(donor = factor(donor, unique(donor))) %&gt;% tidyr::gather(key = &quot;time&quot;, value = &quot;absorbance&quot;, -donor) %&gt;% tidyr::separate(time, c(&quot;time&quot;, &quot;replicate&quot;)) %&gt;% dplyr::mutate(time = as.integer(time)) %&gt;% dplyr::group_by(donor, time) donors.av &lt;- donors %&gt;% dplyr::summarise(absorbance.av = mean(absorbance)) %&gt;% dplyr::ungroup() # Inspect data donors.av ## # A tibble: 20 x 3 ## donor time absorbance.av ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 0 0.236 ## 2 1 7 0.497 ## 3 1 30 0.660 ## 4 1 60 0.804 ## 5 1 180 0.382 ## 6 2 0 0.434 ## 7 2 7 0.629 ## 8 2 30 0.776 ## 9 2 60 0.760 ## 10 2 180 0.660 ## 11 3 0 0.347 ## 12 3 7 1.25 ## 13 3 30 0.837 ## 14 3 60 0.768 ## 15 3 180 0.563 ## 16 4 0 0.932 ## 17 4 7 1.17 ## 18 4 30 1.01 ## 19 4 60 0.845 ## 20 4 180 0.950 Before we proceed with the analysis, let’s plot the data and see whether it looks reasonable. "],
["plot-data.html", "3 Plot data 3.1 Define plot theme 3.2 Plot standard 3.3 Plot biological samples 3.4 Combine plots", " 3 Plot data For convenience, we first define a plot theme: 3.1 Define plot theme min.absorb &lt;- min(blanks$blank) max.absorb &lt;- max(standard$absorbance) font.size &lt;- 12 # Define theme for plotting #&#39; @param title.hjust horizontal alignment of plot title #&#39; @param legend_pos legend position #&#39; @return theme for ggplot theme_plot &lt;- function( title.hjust = 0, legend.pos = &quot;right&quot;, legend.dir = &quot;vertical&quot;) { theme( axis.text = element_text( size = font.size, face = &quot;bold&quot; ), axis.title.x = element_text( size = font.size, hjust = 1 ), axis.title.y = element_text( size = font.size, hjust = 0.9 ), plot.title = element_text( size = font.size + 2, face = &quot;bold&quot;, hjust = title.hjust ), plot.margin = rep(grid::unit(1, &quot;cm&quot;), 4), strip.text.x = element_text(size = font.size), strip.text.y = element_text(size = font.size), strip.background = element_rect(fill = &quot;white&quot;), axis.line = element_blank(), legend.position = legend.pos, legend.direction = legend.dir, legend.text = element_text(size = font.size), legend.title = element_text(size = font.size) ) + background_grid( major = &quot;yx&quot;, minor = &quot;&quot;, colour.major = &quot;grey90&quot;, size.major = 0.2 ) } 3.2 Plot standard Now let’s plot the standard: plot.std &lt;- function(semilog = FALSE) { p &lt;- ggplot(data = standard) + scale_color_brewer( palette = &quot;Set1&quot;, labels = paste(&quot;Replicate&quot;, seq(n.repl.std)), guide = guide_legend(title = &quot;&quot;) ) + scale_y_continuous( limits = c(min.absorb, max.absorb + 0.1 * max.absorb) ) + geom_hline( yintercept = mean(blanks$blank), lty = 2, color = &quot;grey60&quot;, lwd = 0.2 ) + theme_plot() if (semilog == TRUE) { p &lt;- p + geom_point(aes(concentration, absorbance, color = replicate), alpha = 0.6) + labs( x = &quot;Rel. concentration&quot;, y = &quot;Absorbance (a. u.)&quot;, title = &quot;IgG in standard serum&quot; ) + scale_x_continuous(breaks = concentrations, labels = scales::percent, trans = &quot;log2&quot;) + annotate(&quot;text&quot;, label = &quot;Blank&quot;, x = max(standard$concentration) - 0.05 * max(standard$concentration), y = max(blanks$blank) + 20 * max(blanks$blank), size = 3.5, color = &quot;grey50&quot; ) } else { p &lt;- p + geom_point( aes(concentration, absorbance, color = replicate), alpha = 0.6 ) + labs( x = &quot;Rel. concentration&quot;, y = &quot;Absorbance (a.u.)&quot;, title = &quot;IgG in standard serum&quot; ) + scale_x_continuous(breaks = round(concentrations,1), labels = scales::percent) + annotate(&quot;text&quot;, label = &quot;Blank&quot;, x = max(standard$concentration) - 0.05 * max(standard$concentration), y = max(blanks$blank) + 0.2 * max(blanks$blank), size = 3.5, color = &quot;grey50&quot; ) } p } plot.std() We see that the concentration of the dilution series is on a logarithmic scale. Let’s replot the results with \\(\\log_2\\)-transformed concentrations (\\(\\log_2\\) for a dilution factor of 2): plot.std(semilog = TRUE) 3.3 Plot biological samples Now let’s have a look at our actual data. We measured IgG in serum of four donors on five different time points. We first define a plot for our biological samples and then plot it together with the standard curve to have a better overview. plot.donors &lt;- ggplot() + geom_point(data = donors, aes(time, absorbance, color = donor, shape = replicate), alpha = 0.7) + geom_line(data = donors.av, aes(time, absorbance.av, group = donor, color = donor), alpha = 0.6, lwd = 0.5) + labs( x = &quot;Days after vaccination&quot;, y = &quot;Absorbance (a. u.)&quot;, title = &quot;IgG in serum of healthy volunteers&quot; ) + scale_color_viridis( begin = 0.2, end = 0.8, discrete = TRUE, labels = paste(&quot;Donor&quot;, seq(n.donors)), guide = guide_legend(title = &quot;&quot;) ) + scale_y_continuous(limits = c(min.absorb, max.absorb + 0.1 * max.absorb)) + scale_x_continuous(breaks = tpoints) + geom_hline( yintercept = mean(blanks$blank), lty = 2, color = &quot;grey60&quot;, lwd = 0.2 ) + annotate(&quot;text&quot;, label = &quot;Blank&quot;, x = max(donors$time) - 0.1 * max(donors$time), y = max(blanks$blank) + 20 * max(blanks$blank), size = 3.5, color = &quot;grey50&quot; ) + background_grid( major = &quot;yx&quot;, minor = &quot;&quot;, colour.major = &quot;grey90&quot;, size.major = 0.2 ) + theme_plot() plot.donors 3.4 Combine plots plot_grid(plot.std(semilog = TRUE), plot.donors, ncol = 1) "],
["calibration.html", "4 Estimate calibration curve 4.1 The four-parameter logistic curve 4.2 Regression of the standard", " 4 Estimate calibration curve 4.1 The four-parameter logistic curve The relationship between concentration and absorbance can be described by the so called four-parameter logistic equation (4-PL). We will use the following equation: \\[A = f(c) = \\mathrm{A_{min}} + \\frac{\\mathrm{A_{max}} - \\mathrm{A_{min}}}{1+\\exp(\\mathrm{n} \\cdot (\\log_2(c)-\\log_2(\\mathrm{EC}_{50})))}\\], where \\(\\mathrm{A}\\) stands for absorbance and \\(c\\) for concentration. The parameters that we are going to estimate are \\(\\mathrm{A_{max}}\\), which is the maximal absorbance that can be obtained (for infinite concentration \\(c \\rightarrow \\infty\\)), \\(\\mathrm{A_{min}}\\), which is the minimum absorbance that can be obtained (for \\(c \\rightarrow 0\\)), and parameters \\(\\mathrm{EC}_{50}\\) and \\(n\\). The value of \\(\\log_2 \\mathrm{EC}_{50}\\) is the inflection point of the curve. This means, \\(\\log_2 \\mathrm{EC}_{50}\\) is the concentration for which we obtain 50% of \\(\\mathrm{A_{max}}\\). Parameter \\(n\\) is related to the steepness of the curve at the inflection point. For convenience, we use \\(\\log_2\\) in the equation (and not \\(log_{10}\\) as often used in literature), because then the estimated \\(\\log_2 EC_{50}\\) is easier to interpret, since we performed a 1:2 dilution series to generate the concentrations of our standard. Note that \\(\\log_2(x) = \\frac{log_{10}(x)}{log_2(10)} = 0.30103 \\cdot \\log_{10}(x)\\). Changing the base simply scales all concentration by a constant value (linear transformation). 4.2 Regression of the standard We fit the data obtained for the standard to the four-parameter logistic curve. This is a non-linear least squares problem and we use the Levenberg-Marquadt algorithm to solve it. The Levenberg-Marquardt algorithm is more robust than the Gauss–Newton algorithm (used by default by the nls() function of the nls package), which means it converges to a minimum even if the initial starting values are far from the final minimum. # Fit 4-parameter logistic dose-response curve # Approach 1): Use nlsLM pacakge for Levenberg-Marquardt optimization standard &lt;- standard %&gt;% dplyr::mutate(log2concentration = log2(concentration)) levm.fit &lt;- nlsLM( absorbance ~ Amin + ((Amax - Amin) / (1 + exp(n * (log2concentration - log2EC50)))), data = standard, start = list(Amin = 0, Amax = 2, log2EC50 = 0.5, n = -1) ) # Show summary of the fit summary(levm.fit) ## ## Formula: absorbance ~ Amin + ((Amax - Amin)/(1 + exp(n * (log2concentration - ## log2EC50)))) ## ## Parameters: ## Estimate Std. Error t value Pr(&gt;|t|) ## Amin -0.05700 0.05978 -0.954 0.359117 ## Amax 2.44950 0.39531 6.196 4.61e-05 *** ## log2EC50 -1.29803 0.49578 -2.618 0.022462 * ## n -0.64181 0.11414 -5.623 0.000112 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.05644 on 12 degrees of freedom ## ## Number of iterations to convergence: 10 ## Achieved convergence tolerance: 1.49e-08 Apparently, we can not estimate \\(\\mathrm{A_{min}}\\) from the data. But we can fix it to a certain value: we know that \\(\\mathrm{A_{min}}\\) can not be negative and we can use the values obtained from the blank wells as an estimate for \\(\\mathrm{A_{min}}\\). # Set Amin to blank values Amin &lt;- median(blanks$blank) # Re-fit with only three free parameters levm.fit &lt;- nlsLM( absorbance ~ Amin + ((Amax - Amin) / (1 + exp(n * (log2concentration - log2EC50)))), data = standard, start = list(Amax = 2, log2EC50 = 0.5, n = -1) ) # Check new fit results summary(levm.fit) ## ## Formula: absorbance ~ Amin + ((Amax - Amin)/(1 + exp(n * (log2concentration - ## log2EC50)))) ## ## Parameters: ## Estimate Std. Error t value Pr(&gt;|t|) ## Amax 2.21560 0.20145 10.998 5.90e-08 *** ## log2EC50 -1.53719 0.29608 -5.192 0.000174 *** ## n -0.74553 0.06922 -10.771 7.55e-08 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.05767 on 13 degrees of freedom ## ## Number of iterations to convergence: 9 ## Achieved convergence tolerance: 1.49e-08 # Get 95% confidence interval confint(levm.fit) ## 2.5% 97.5% ## Amax 1.8848732 2.8761358 ## log2EC50 -2.0560171 -0.6645695 ## n -0.9010853 -0.6099279 ## Add calibration curve to plot # Save estimated parameters Amax.est &lt;- coef(levm.fit)[[1]] log2EC50.est &lt;- coef(levm.fit)[[2]] n.est &lt;- coef(levm.fit)[[3]] # Full range of considered concentrations log2concentration.new &lt;- log2(seq(0.008, 1, by = 0.001)) # Predict new absorbance values from calibration curve calibration.curve &lt;- tibble( concentration.new = 2^log2concentration.new, log2concentration.new = log2concentration.new, absorbance.est = predict(levm.fit, tibble(log2concentration = log2concentration.new)) ) ## Compute prediction and confidence intervals # TODO: double-check, ignore this part for now fgh &lt;- deriv( absorbance ~ Amin + ((Amax - Amin) / (1 + exp(n * (log2concentration - log2EC50)))), c(&quot;Amax&quot;, &quot;log2EC50&quot;, &quot;n&quot;), function(Amax, log2EC50, n, log2concentration) {} ) f.new &lt;- fgh(Amax.est, log2EC50.est, n.est, log2concentration.new) g.new &lt;- attr(f.new, &quot;gradient&quot;) cov.fit &lt;- vcov(levm.fit) gs &lt;- rowSums((g.new %*% cov.fit) * g.new) alpha &lt;- 0.05 delta.f &lt;- sqrt(gs) * qt(1 - alpha/2, 15) sigma.est &lt;- summary(levm.fit)$sigma delta.y &lt;- sqrt(gs + sigma.est^2) * qt(1 - alpha / 2, 15) calibration.curve &lt;- calibration.curve %&gt;% dplyr::mutate(pred.lwr = absorbance.est - delta.y) %&gt;% dplyr::mutate(pred.upr = absorbance.est + delta.y) %&gt;% dplyr::mutate(conf.lwr = absorbance.est - delta.f) %&gt;% dplyr::mutate(conf.upr = absorbance.est + delta.f) ## Plot calibration curve plot.ccurve &lt;- plot.std(semilog = TRUE) + geom_line( data = calibration.curve, aes(concentration.new, absorbance.est), alpha = 0.8 ) + geom_ribbon( data = calibration.curve, aes(x = concentration.new, ymin = pred.lwr, ymax = pred.upr), alpha = 0.2, fill = &quot;grey&quot; ) + geom_ribbon( data = calibration.curve, aes(x = concentration.new, ymin = conf.lwr, ymax = conf.upr), alpha = 0.1, fill = NA, color = &quot;grey70&quot;, lty = 3 ) + scale_y_continuous(limits = c(-0.3, 2)) # TODO: Add ribbon and dashed line to legend plot.ccurve The grey band shows the prediction interval and the dashed line the confidence interval (both for 95%). # Plot predicted absorbance vs residuals plot(levm.fit) Alternatively, one can use the drc package to fit a 4-PL curve using. However, the drm function performs a \\(\\ln\\) transformation of the independent variable by itself. So in this case, the results are for \\(\\ln\\)-transformed concentrations: # Fit 4-parameter logistic dose-response curve # Approach 2): Use drc package # NOTE: the drm function performs a ln(x) transformation by itself. # See also ?LL2.4 for more information drc.fit &lt;- drm(absorbance ~ concentration, data = standard, fct = LL2.4(names = c(&quot;n&quot;, &quot;Amin&quot;, &quot;Amax&quot;, &quot;EC50&quot;)) ) summary(drc.fit) ## ## Model fitted: Log-logistic (log(ED50) as parameter) (4 parms) ## ## Parameter estimates: ## ## Estimate Std. Error t-value p-value ## n:(Intercept) -0.926589 0.154888 -5.9823 6.388e-05 *** ## Amin:(Intercept) -0.056483 0.055791 -1.0124 0.33132 ## Amax:(Intercept) 2.449055 0.383663 6.3834 3.487e-05 *** ## EC50:(Intercept) -0.899679 0.337454 -2.6661 0.02056 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: ## ## 0.05644039 (12 degrees of freedom) plot(drc.fit) ggplot(as.tibble(drc.fit$predres)) + geom_point(aes(`Predicted values`, Residuals), pch = 1, size = 3, color = &quot;cornflowerblue&quot;) + theme_plot() + panel_border() + geom_hline(yintercept = 0, lwd = 0.2) Using the estimated parameters and the 4-PL equation, we can estimate unknown concentrations based on measured absorbance. "],
["results.html", "5 Results 5.1 Compute concentrations 5.2 Plot results", " 5 Results 5.1 Compute concentrations Rearranging the 4-PL equation for concentration \\(c\\) gives: \\[\\log_2(c) = \\log_2(\\mathrm{EC}_{50}) + \\dfrac{1}{n} \\cdot \\ln \\left(\\dfrac{\\mathrm{A_{max} - A_{min}}}{A - \\mathrm{A_{min}}} \\right) \\]. We compute the concentrations of our biological samples using the estimated calibration curve and plot the results: log2concentration.est &lt;- sapply(donors.av$absorbance.av, function(x) log2EC50.est + (1/n.est) * log((Amax.est - Amin)/(x - Amin))) # Get confidence intervals fgh &lt;- deriv( log2concentration ~ log2EC50 + (1/n) * log((Amax - Amin)/(A - Amin)), c(&quot;Amax&quot;, &quot;log2EC50&quot;, &quot;n&quot;), function(Amax, log2EC50, n, A) {} ) f.new &lt;- fgh(Amax.est, log2EC50.est, n.est, donors.av$absorbance.av) g.new &lt;- attr(f.new, &quot;gradient&quot;) gs &lt;- rowSums((g.new %*% cov.fit) * g.new) alpha &lt;- 0.05 delta.f &lt;- sqrt(gs) * qt(1 - alpha/2, 15) results &lt;- donors.av %&gt;% dplyr::mutate(concentration.est = 2^log2concentration.est) %&gt;% dplyr::mutate(log2concentration.est = log2concentration.est) %&gt;% dplyr::mutate(log2conf = delta.f) # Inspect results head(results) ## # A tibble: 6 x 6 ## donor time absorbance.av concentration.est log2concentration.… log2conf ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 0 0.236 0.0422 -4.57 0.327 ## 2 1 7 0.497 0.0852 -3.55 0.198 ## 3 1 30 0.660 0.111 -3.17 0.185 ## 4 1 60 0.804 0.134 -2.90 0.195 ## 5 1 180 0.382 0.0665 -3.91 0.232 ## 6 2 0 0.434 0.0751 -3.74 0.213 5.2 Plot results plot.results &lt;- ggplot( data = results, aes(time, concentration.est, color = donor) ) + geom_line(aes(time, concentration.est, group = donor), alpha = 0.6, lwd = 0.5 ) + labs( x = &quot;Days after vaccination&quot;, y = &quot;Relative concentration&quot;, title = &quot;IgG in healthy volunteers&quot; ) + scale_color_viridis( begin = 0.2, end = 0.8, discrete = TRUE, labels = paste(&quot;Donor&quot;, seq(n.donors)), guide = guide_legend(title = &quot;&quot;) ) + scale_x_continuous(breaks = tpoints) + background_grid( major = &quot;yx&quot;, minor = &quot;&quot;, colour.major = &quot;grey90&quot;, size.major = 0.2 ) + theme_plot() + geom_pointrange( aes(ymin = concentration.est / 2^log2conf, ymax = concentration.est * 2^log2conf), shape = 21, size = 0.4 ) + scale_y_continuous(labels = scales::percent) plot.results "],
["overview.html", "Overview", " Overview plot_grid(plot.ccurve, plot.donors, plot.results, ncol = 1) "]
]
